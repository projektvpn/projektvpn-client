<!DOCTYPE html>
<html>
  <head>
    <title>ProjektVPN Client</title>
    <script type="text/javascript" src="js/ractive.min.js"></script>
    <script type="text/javascript">
      const cjdnsAdmin = require('cjdns-admin')
      // We need FS access for reading the ractive templates
      const fs = require('fs')
      // We also use async
      const async = require('async')
      // We need to be able to prompt for sudo/elvation
      const sudoPrompt = require('sudo-prompt')
      // We need this for parsing cjdns configs
      const JSON5 = require('json5')
      // Set up a settings manager
      const settings = require('user-settings').file('.projektvpn-client')
      
      // We will populate this with the cjdnsAdmin instance
      var admin = null
      
      // We use this global ractive
      var ractive = null
      
      // Ping cjdns and update the UI with its response
      // Do it every second or so. Assumes the ractive exists.
      function pingCjdns() {
        if (!admin) {
          ractive.set('cjdns_reachable', false)
          setTimeout(pingCjdns, 1000)
        } else {
          // If we don't get a pong in 1 second, cjdns isn't working
          var cjdns_timeout = setTimeout(() => {
            ractive.set('cjdns_reachable', false)
            setTimeout(pingCjdns, 1000)
          }, 1000)
    
          admin.once(admin.ping(), (res) => {
            clearTimeout(cjdns_timeout)
            ractive.set('cjdns_reachable', true)
            setTimeout(pingCjdns, 1000)
          })
        }
      }

      // We have a function to guess the config path. Calls the callback with
      // null and the appropriate path (or null), or an error
      function guessConfigPath(callback) {
        
        // We know where fils ought to be by default
        var possible_paths = ['/etc/cjdroute.conf', 'C:\\Program Files (x86)\\cjdns\\cjdroute.conf']
        
        async.map(possible_paths, (item, callback) => {
          // See if each file exists
          fs.access(item, fs.constants.F_OK, (err) => {
            if (err) {
              // File does not exist (or is hiding from us)
              callback(null, false)
            } else {
              // File exists
              callback(null, true)
            }
          })
        }, (err, results) => {
          if (err) {
            // Something went wrong during iteration
            return callback(err)
          }
          
          for (var i = 0; i < results.length; i++) {
            // Consider the existence flag for each filename
            if (results[i] == true) {
              // We found one that exists. Tell the caller
              return callback(null, possible_paths[i])
            }
          }
          
          // If we make it here, no file exists
          callback(null, null)
        })
        
      }
      
      // Call the callback with an error, or null and the contents of the given
      // file. If the file is not accessible by the current user, it will be
      // read via an elevated command.
      function catProtectedFile(filename, callback) {
        fs.access(filename, fs.constants.R_OK, (err) => {
          if (err) {
            // File is not accessible to this user
            
            // What command should we use? Windows is different than everyone else.
            var cat_command = /^win/.test(process.platform) ? 'type' : 'cat'
            
            sudoPrompt.exec(cat_command + ' "' + filename + '"', {}, function(err, stdout, stderr) {
              // OK we launched the sudo command
              if (err) {
                return callback(err)
              }
              
              if (stderr != "") {
                return callback(new Error('Config read command complained: ' + stderr))
              }
              
              // Send back the contents of standard out
              callback(null, stdout)
            }) 
            
            
          } else {
            // We can read the file ourselves. So do it.
            fs.readFile(filename, 'utf8', callback)
          }
        })
      }

      // Grab the template
      fs.readFile('templates/main.ractive', 'utf8', function(err, data) {
        if (err) {
          throw err
        }
        
        // Then make the ractive
        ractive = new Ractive({
          el: '#container',
          template: data,
          data: {
            pid: 0,
            cjdns_password: settings.get('cjdns_password'),
            cjdns_config_path: settings.get('cjdns_config_path'),
            cjdns_pubkey: settings.get('cjdns_pubkey'),
            should_be_connected: settings.get('should_be_connected') || false,
            // Is cjdns reachable?
            cjdns_ok: false
          }
        })
        
        console.log('Ractive: ', ractive)
        
        // If the cjdns info changes, commit back to settings
        function commit_setting(new_value, old_value, keypath) {
          console.log('Save ', new_value, ' as ', keypath)
          settings.set(keypath, new_value)
        }
        ractive.observe('cjdns_password', commit_setting, {init: false})      
        ractive.observe('cjdns_config_path', commit_setting, {init: false})
        ractive.observe('cjdns_pubkey', commit_setting, {init: false})
        ractive.observe('should_be_connected', commit_setting, {init: false})
        
        // When we have the passord (or on startup), we can set up the cjdns admin object
        ractive.observe('cjdns_password', (new_value) => {
          if (new_value) {
            // Make the admin connection
            admin = cjdnsAdmin.createAdmin({
                ip: 'localhost',
                port: 11234,
                password: new_value
            })
            
            // Anything that wants cjdns will now see that the admin interface
            // is set.
          }
        })
        
        if (!ractive.get('cjdns_config_path')) {
          // No config path is known, so default it
          guessConfigPath((err, path) => {
            if (err) {
              throw err
            }
            
            if (path != null) {
              // Set the path
              ractive.set('cjdns_config_path', path)
            }
          })
        }
        
        // Event handlers
        ractive.on('parse-config', (event) => {
          console.log('Go get the password')
          catProtectedFile(ractive.get('cjdns_config_path'), (err, data) => {
            if (err) {
              throw err
            }
            
            var cjdns_config;
            try {
              cjdns_config = JSON5.parse(data)
            } catch(err) {
              return alert('Error parsing cjdns config file JSON: ' + err)
            }

            console.log(cjdns_config)
            
            // Load pubkey (not accessible through API) and password
            ractive.set('cjdns_pubkey', cjdns_config['publicKey'])
            ractive.set('cjdns_password', (cjdns_config['admin'] || {})['password'])
            
            
          })
        })
        
        console.log('Setup complete!')
        
        // Start the cjdns pinging process
        pingCjdns()
        
      })
    </script>
  </head>
  <body>
    <div id="container"></div>
  </body>
</html>
